package types

import (
	"context"
	"sync"
	"time"
)

type LogEntry struct {
	SeqNum  uint64
	Tags    []uint64
	Data    []byte
	AuxData []byte
}

type Future[T uint64 | *LogEntry] interface {
	GetLocalId() uint64
	GetResult() (T, error)
	Verify(timeout time.Duration) error
}

// TODO: move to an independent package
const (
	FutureTaskState_PENDING   uint8 = 0
	FutureTaskState_FULFILLED uint8 = 1
	FutureTaskState_REJECTED  uint8 = 2
)

type futureImpl[T uint64 | *LogEntry] struct {
	// for append, it's the localid, also book id, generated by log.engine.LogProducer
	// for read, it's the local op id generated by worker
	LocalId uint64

	status uint8
	// result union
	result T
	err    error

	// sync
	wg sync.WaitGroup
}

func NewFuture[T uint64 | *LogEntry](localId uint64, resolve func() (T, error)) Future[T] {
	var emptyRes T
	future := &futureImpl[T]{
		LocalId: localId,
		status:  FutureTaskState_PENDING,
		result:  emptyRes,
		err:     nil,
		wg:      sync.WaitGroup{},
	}
	future.wg.Add(1)
	go func(fu *futureImpl[T]) {
		res, err := resolve()
		if err == nil {
			fu.status = FutureTaskState_FULFILLED
			fu.result = res
			fu.err = nil
		} else {
			fu.status = FutureTaskState_REJECTED
			fu.err = err
		}
		fu.wg.Done()
	}(future)
	return future
}

func (f *futureImpl[T]) GetLocalId() uint64 {
	return f.LocalId
}

func (f *futureImpl[T]) GetResult() (T, error) {
	f.wg.Wait()
	return f.result, f.err
}

func (f *futureImpl[T]) Verify(timeout time.Duration) error {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		f.wg.Wait()
	}
	return nil
}

type Environment interface {
	InvokeFunc(ctx context.Context, funcName string, input []byte) ( /* output */ []byte, error)
	InvokeFuncAsync(ctx context.Context, funcName string, input []byte) error
	GrpcCall(ctx context.Context, service string, method string, request []byte) ( /* reply */ []byte, error)

	GenerateUniqueID() uint64

	// Shared log operations
	// Append a new log entry, tags must be non-zero
	SharedLogAppend(ctx context.Context, tags []uint64, data []byte) ( /* seqnum */ uint64, error)
	// Read the first log with `tag` whose seqnum >= given `seqNum`
	// `tag`==0 means considering log with any tag, including empty tag
	SharedLogReadNext(ctx context.Context, tag uint64, seqNum uint64) (*LogEntry, error)
	SharedLogReadNextBlock(ctx context.Context, tag uint64, seqNum uint64) (*LogEntry, error)
	// Read the last log with `tag` whose seqnum <= given `seqNum`
	// `tag`==0 means considering log with any tag, including empty tag
	SharedLogReadPrev(ctx context.Context, tag uint64, seqNum uint64) (*LogEntry, error)
	// Alias for ReadPrev(tag, MaxSeqNum)
	SharedLogCheckTail(ctx context.Context, tag uint64) (*LogEntry, error)
	// Set auxiliary data for log entry of given `seqNum`
	SharedLogSetAuxData(ctx context.Context, seqNum uint64, auxData []byte) error

	AsyncSharedLogAppend(ctx context.Context, tags []uint64, data []byte) (Future[uint64], error)
	AsyncSharedLogReadNext(ctx context.Context, tag uint64, future Future[uint64]) (Future[*LogEntry], error)
}

type FuncHandler interface {
	Call(ctx context.Context, input []byte) ( /* output */ []byte, error)
}

type GrpcFuncHandler interface {
	Call(ctx context.Context, method string, request []byte) ( /* reply */ []byte, error)
}

type FuncHandlerFactory interface {
	New(env Environment, funcName string) (FuncHandler, error)
	GrpcNew(env Environment, service string) (GrpcFuncHandler, error)
}
