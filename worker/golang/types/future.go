package types

import (
	"context"
	"sync"
	"time"
)

const (
	FutureTaskState_PENDING  uint8 = 0
	FutureTaskState_RESOLVED uint8 = 1
	FutureTaskState_REJECTED uint8 = 2
)

// Serializable
type FutureMeta struct {
	// for append, it's the localid, also book id, generated by log.engine.LogProducer
	// for read, it's the local op id generated by worker
	LocalId uint64 `json:"localid"`
	State   uint8  `json:"state"`
}

// Implement types.Future
type futureImpl[T uint64 | *CondLogEntry] struct {
	FutureMeta
	// result union
	result T
	err    error

	// sync
	wg sync.WaitGroup
}

func NewFuture[T uint64 | *CondLogEntry](localId uint64, resolve func() (T, error)) Future[T] {
	var emptyRes T
	future := &futureImpl[T]{
		FutureMeta: FutureMeta{
			LocalId: localId,
			State:   FutureTaskState_PENDING,
		},
		result: emptyRes,
		err:    nil,
		wg:     sync.WaitGroup{},
	}
	future.wg.Add(1)
	go func(fu *futureImpl[T]) {
		res, err := resolve()
		if err == nil {
			fu.State = FutureTaskState_RESOLVED
			fu.result = res
			fu.err = nil
		} else {
			fu.State = FutureTaskState_REJECTED
			fu.err = err
		}
		fu.wg.Done()
	}(future)
	return future
}

func (f *futureImpl[T]) GetLocalId() uint64 {
	return f.LocalId
}

func (f *futureImpl[T]) GetResult() (T, error) {
	f.wg.Wait()
	return f.result, f.err
}

func (f *futureImpl[T]) Await(timeout time.Duration) error {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		f.wg.Wait()
	}
	return nil
}

func (f *futureImpl[T]) GetMeta() FutureMeta {
	return FutureMeta{
		LocalId: f.LocalId,
		State:   f.State,
	}
}

type asyncLogContextImpl struct {
	env         Environment
	asyncLogOps []FutureMeta
}

func NewAsyncLogContext(env Environment) AsyncLogContext {
	return &asyncLogContextImpl{
		env:         env,
		asyncLogOps: make([]FutureMeta, 0),
	}
}

func DeserializeAsyncLogChain(data []byte) (AsyncLogContext, error) {
	// TODO
	panic("not implemented")
}

func (fc *asyncLogContextImpl) Chain(future FutureMeta) AsyncLogContext {
	fc.asyncLogOps = append(fc.asyncLogOps, future)
	return fc
}

func (fc *asyncLogContextImpl) Sync(timeout time.Duration) error {
	// TODO
	panic("not implemented")

	// futures := make([]Future[*LogEntry], 0, len(fc.asyncLogOps))
	// ctx := context.Background()
	// ctx, cancel := context.WithTimeout(ctx, timeout)
	// defer cancel()
	// for _, futureMeta := range fc.asyncLogOps {
	// 	futures = append(futures, NewFuture[*LogEntry](futureMeta.localId, func() (*LogEntry, error) {
	// 		// TODO
	// 	}))
	// }
}

func (fc *asyncLogContextImpl) Serialize() ([]byte, error) {
	// TODO
	panic("not implemented")
}
