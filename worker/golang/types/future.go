package types

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/pkg/errors"
)

const (
	FutureTaskState_PENDING  uint8 = 0
	FutureTaskState_RESOLVED uint8 = 1
	FutureTaskState_REJECTED uint8 = 2
)

// Serializable
type FutureMeta struct {
	// for append, it's the localid, also book id, generated by log.engine.LogProducer
	// for read, it's the local op id generated by worker
	LocalId uint64 `json:"localid"`
	State   uint8  `json:"state"`
}

func (fm FutureMeta) Serialize() ([]byte, error) {
	return json.Marshal(fm)
}
func DeserializeFutureMeta(data []byte) (FutureMeta, error) {
	var fm FutureMeta
	err := json.Unmarshal(data, &fm)
	return fm, errors.Wrapf(err, "invalid data: %v", data)
}

// Implement types.Future
type futureImpl[T uint64 | *CondLogEntry] struct {
	metaStateMu sync.RWMutex
	FutureMeta
	// result union
	result T
	err    error

	// sync
	wg sync.WaitGroup
}

func NewFuture[T uint64 | *CondLogEntry](localId uint64, resolve func() (T, error)) Future[T] {
	var emptyRes T
	future := &futureImpl[T]{
		metaStateMu: sync.RWMutex{},
		FutureMeta: FutureMeta{
			LocalId: localId,
			State:   FutureTaskState_PENDING,
		},
		result: emptyRes,
		err:    nil,
		wg:     sync.WaitGroup{},
	}
	future.wg.Add(1)
	go func(fu *futureImpl[T]) {
		res, err := resolve()
		if err == nil {
			fu.metaStateMu.Lock()
			fu.State = FutureTaskState_RESOLVED
			fu.metaStateMu.Unlock()
			fu.result = res
			fu.err = nil
		} else {
			fu.metaStateMu.Lock()
			fu.State = FutureTaskState_REJECTED
			fu.metaStateMu.Unlock()
			fu.err = err
		}
		fu.wg.Done()
	}(future)
	return future
}

func (f *futureImpl[T]) GetLocalId() uint64 {
	return f.LocalId
}

func (f *futureImpl[T]) GetResult() (T, error) {
	f.wg.Wait()
	return f.result, f.err
}

func (f *futureImpl[T]) Await(timeout time.Duration) error {
	// log.Printf("wait future=%+v with timeout=%v", f, timeout)
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	awaitDone := make(chan struct{})
	go func() {
		f.wg.Wait()
		awaitDone <- struct{}{}
	}()

	select {
	case <-ctx.Done():
		// log.Printf("wait future=%+v timeout", f)
		return ctx.Err()
	case <-awaitDone:
		// log.Printf("wait future=%+v without error", f)
		return nil
	}
}

func (f *futureImpl[T]) GetMeta() FutureMeta {
	f.metaStateMu.RLock()
	defer f.metaStateMu.RUnlock()
	return FutureMeta{
		LocalId: f.LocalId,
		State:   f.State,
	}
}

type asyncLogContextImpl struct {
	env         Environment // delegation
	mu          sync.Mutex
	asyncLogOps []FutureMeta
}

func DebugNewAsyncLogContext() AsyncLogContext {
	return &asyncLogContextImpl{
		env:         nil,
		mu:          sync.Mutex{},
		asyncLogOps: make([]FutureMeta, 0, 20),
	}
}
func NewAsyncLogContext(env Environment) AsyncLogContext {
	return &asyncLogContextImpl{
		env:         env,
		asyncLogOps: make([]FutureMeta, 0, 20),
	}
}

func (fc *asyncLogContextImpl) Chain(future FutureMeta) AsyncLogContext {
	fc.mu.Lock()
	fc.asyncLogOps = append(fc.asyncLogOps, future)
	fc.mu.Unlock()
	return fc
}

func (fc *asyncLogContextImpl) Sync(timeout time.Duration) error {
	fc.mu.Lock()
	defer fc.mu.Unlock()

	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	wg := sync.WaitGroup{}
	errCh := make(chan error)
	for _, futureMeta := range fc.asyncLogOps {
		wg.Add(1)
		go func(futureMeta FutureMeta) {
			if future, err := fc.env.AsyncSharedLogReadIndex(ctx, futureMeta); err != nil {
				errCh <- err
			} else if err := future.Await(timeout); err != nil {
				errCh <- err
			} else {
				// log.Printf("wait future=%+v done", future)
				// seqNum, err := future.GetResult()
				// log.Printf("wait futureMeta.LocalId=0x%016X state=%v seqNum=0x%016X err=%v",
				// 	futureMeta.LocalId, futureMeta.State, seqNum, err)
			}
			wg.Done()
		}(futureMeta)
	}
	waitCh := make(chan struct{})
	go func() {
		wg.Wait()
		waitCh <- struct{}{}
	}()

	select {
	case <-ctx.Done():
		// log.Println("wait future all done timeout")
		return ctx.Err()
	case err := <-errCh:
		// log.Println("wait future all done with error:", err)
		return err
	case <-waitCh:
		// log.Println("wait future all done without error")
		return nil
	}
}

func (fc *asyncLogContextImpl) Serialize() ([]byte, error) {
	fc.mu.Lock()
	defer fc.mu.Unlock()
	asyncLogCtxData, err := json.Marshal(fc.asyncLogOps)
	if err != nil {
		return nil, err
	}
	// DEBUG
	if len(asyncLogCtxData) == 0 {
		panic(fmt.Sprintf("empty asyncLogCtxData: %v", asyncLogCtxData))
	}
	return asyncLogCtxData, nil
}

func (fc *asyncLogContextImpl) Truncate() {
	fc.asyncLogOps = make([]FutureMeta, 0, 100)
}

func DeserializeAsyncLogContext(env Environment, data []byte) (AsyncLogContext, error) {
	var asyncLogOps []FutureMeta
	err := json.Unmarshal(data, &asyncLogOps)
	if err != nil {
		return nil, errors.Wrapf(err, "unresolvable data: %v", data)
	}
	return &asyncLogContextImpl{
		env:         env,
		asyncLogOps: asyncLogOps,
	}, nil
}

// DEBUG
func (fc *asyncLogContextImpl) String() string {
	return fmt.Sprintf("ops=%+v", fc.asyncLogOps)
}
